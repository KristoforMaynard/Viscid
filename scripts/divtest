#!/usr/bin/env python

from __future__ import print_function
import sys
import cProfile
from timeit import timeit
from time import time
from warnings import warn
import resource

import numpy as np
import numexpr as ne
import pylab as pl
from matplotlib.colors import LogNorm

from viscid import readers
from viscid import field
from viscid import coordinate
from viscid.calculator import calc, cycalc
from viscid.plot import mpl

def timereps(reps, func, *args, **kwargs):
    arr = [None] * reps
    for i in range(reps):
        start = time()
        func(*args, **kwargs)
        end = time()
        arr[i] = end - start
    return min(arr), max(arr), sum(arr) / reps

if __name__=="__main__":
    dtype = 'float64'

    try:
        sys.argv.remove("--plot")
        plot = True
    except ValueError:
        plot = False

    t0 = time()

    x = np.array(np.linspace(-0.5, 0.5, 64), dtype=dtype)
    y = np.array(np.linspace(-0.5, 0.5, 64), dtype=dtype)
    z = np.array(np.linspace(-0.5, 0.5, 64), dtype=dtype)

    crds = coordinate.wrap_crds("Rectilinear", (('z', z), ('y', y), ('x', x)))
    Z, Y, X = crds.get_nc(shaped=True)
    Zcc, Ycc, Xcc = crds.get_cc(shaped=True)

    half = np.array([0.5], dtype=dtype)
    two = np.array([2.0], dtype=dtype)

    vx_cc = ne.evaluate("(sin(Xcc))")  # + Zcc
    vy_cc = ne.evaluate("(cos(Ycc))")  # + Xcc# + Zcc
    vz_cc = ne.evaluate("-((sin(Zcc)))")  # + Xcc# + Ycc
    exact_div_cc = ne.evaluate("cos(Xcc) - "
                               "sin(Ycc) - "
                               "cos(Zcc)")

    # cell centered field and exact divergence
    fld_v_cc = field.VectorField("v_cc", crds, [vx_cc, vy_cc, vz_cc],
                                 force_layout=field.LAYOUT_INTERLACED,
                                 center="Cell", forget_source=True)
    fld_div_cc = field.ScalarField("exact div", crds, exact_div_cc,
                                   center="Cell", forget_source=True)
    fld_vx_cc, fld_vy_cc, fld_vz_cc = fld_v_cc.component_fields()

    t1 = time()
    print("field setup time: ", t1 - t0)

    t0 = time()
    #result_numexpr = calc.magnitude(fld_v, func="numexpr")
    result_numexpr = calc.div(fld_v_cc, func="numexpr")
    t1 = time()
    print("numexpr magnitude runtime: ", t1 - t0)

    # t0 = time()
    # result_numpy = calc.magnitude(fld_v, func="numpy")
    # t1 = time()
    # print("numpy runtime: ", t1 - t0)

    t0 = time()
    #result_cython = cycalc.magnitude(fld_v)
    result_cython = calc.div(fld_v_cc, func="cython")
    t1 = time()
    print("cython runtime: ", t1 - t0)

    # t0 = time()
    # result_native = calc.magnitude([fld_vx, fld_vy, fld_vz], func="native")
    # t1 = time()
    # print("native runtime: ", t1 - t0)

    # print("numexpr shape: ", result_numexpr.shape)
    # print("cython shape: ", result_cython.shape)

    tolerance = 1e-6
    diff_ne = calc.difference(result_numexpr, fld_div_cc, slb=[np.s_[1:-1]]*3)
    abs_diff_ne = np.abs(diff_ne.data)
    if not (abs_diff_ne < tolerance).all():
        warn("numexpr result not within {0} of exact".format(tolerance))
    print("min/max(numexpr - exact): ", np.min(abs_diff_ne), "/",
          np.max(abs_diff_ne))

    tolerance = 1e-6
    diff_cy = calc.difference(result_cython, fld_div_cc, slb=[np.s_[1:-1]]*3)
    abs_diff_cy = np.abs(diff_cy.data)
    if not (abs_diff_cy < tolerance).all():
        warn("cython result not within {0} of exact".format(tolerance))
    print("min/max(cython - exact): ", np.min(abs_diff_cy), "/",
          np.max(abs_diff_cy))

    diff_ne_cy = calc.difference(result_numexpr, result_cython)
    abs_diff_ne_cy = np.abs(diff_ne_cy.data)
    if not (abs_diff_ne_cy < tolerance).all():
        warn("cython result not within {0} of numexpr".format(tolerance))
    print("min/max(numexpr - cython): ", np.min(abs_diff_ne_cy), "/",
          np.max(abs_diff_ne_cy))


    if plot:
        planes = ["y=0.", "z=0."]
        nrows = 6
        ncols = len(planes)
        ax = pl.subplot2grid((nrows, ncols), (0, 0))
        ax.axis("equal")

        for i, p in enumerate(planes):
            pl.subplot2grid((nrows, ncols), (0, i), sharex=ax, sharey=ax)
            mpl.plot(fld_vx_cc, p, show=False)
            pl.subplot2grid((nrows, ncols), (1, i), sharex=ax, sharey=ax)
            mpl.plot(fld_vy_cc, p, show=False)
            pl.subplot2grid((nrows, ncols), (2, i), sharex=ax, sharey=ax)
            mpl.plot(fld_vz_cc, p, show=False)
            pl.subplot2grid((nrows, ncols), (3, i), sharex=ax, sharey=ax)
            mpl.plot(fld_div_cc, p, show=False)
            pl.subplot2grid((nrows, ncols), (4, i), sharex=ax, sharey=ax)
            mpl.plot(result_numexpr, p, show=False)
            pl.subplot2grid((nrows, ncols), (5, i), sharex=ax, sharey=ax)
            mpl.plot(diff_ne, p, show=False)
            # pl.subplot2grid((nrows, ncols), (5, i), sharex=ax, sharey=ax)
            # mpl.plot(diff_ne_cy, p, show=False)
        mpl.mplshow()

##
## EOF
##
